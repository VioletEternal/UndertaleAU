{"posts":[{"title":"【题解】P1462 通往奥格瑞玛的道路","content":"题目链接： 传送门 题解大意： 对于一道有着两个限制条件（即血量与金钱）的图论搜索题，首选BFS 开玩笑的啦，BFS这道题铁定会超，无论空间还是时间。 二分价格，看在血量够的情况下是否能到达终点。 时间复杂度： 二分： O(log109)O(log10^9)O(log109) SPFA： O(kn)O(kn)O(kn) 稳稳地不会超 AC Code: ","link":"https://violeteternal.github.io/post/ti-jie-p1462-tong-wang-ao-ge-rui-ma-de-dao-lu/"},{"title":"【学习笔记】矩阵","content":"矩阵： 矩阵(Matrix)是指一个按照长方阵列排列的集合。一个由 nnn 行 mmm 列个数字排列的列表称为“ mmm 行 nnn 列”的矩阵，简称 n∗mn*mn∗m 矩阵，记作： {a1a2a3...amam+1.........a2m...............am(n−1)+1.........anm}\\begin{Bmatrix} a_1&amp;a_2&amp;a_3&amp;...&amp;a_m\\\\ a_{m+1}&amp;...&amp;...&amp;...&amp;a_{2m}\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ a_{m(n-1)+1}&amp;...&amp;...&amp;...&amp;a_{nm} \\end{Bmatrix}⎩⎪⎪⎨⎪⎪⎧​a1​am+1​...am(n−1)+1​​a2​.........​a3​.........​............​am​a2m​...anm​​⎭⎪⎪⎬⎪⎪⎫​ 矩阵加法/减法： 令 A,BA,BA,B 都是 n∗mn*mn∗m 矩阵，则 A+B=CA+B=CA+B=C ，满足： C={a1+b1a2+b2a3+b3...am+bmam+1+bm+1.........a2m+b2m...............am(n−1)+1+bm(n−1)+1.........anm+bnm}C=\\begin{Bmatrix} a_1+b_1&amp;a_2+b_2&amp;a_3+b_3&amp;...&amp;a_m+b_m\\\\ a_{m+1}+b_{m+1}&amp;...&amp;...&amp;...&amp;a_{2m}+b_{2m}\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ a_{m(n-1)+1}+b_{m(n-1)+1}&amp;...&amp;...&amp;...&amp;a_{nm}+b_{nm} \\end{Bmatrix}C=⎩⎪⎪⎨⎪⎪⎧​a1​+b1​am+1​+bm+1​...am(n−1)+1​+bm(n−1)+1​​a2​+b2​.........​a3​+b3​.........​............​am​+bm​a2m​+b2m​...anm​+bnm​​⎭⎪⎪⎬⎪⎪⎫​ 简单来说，即 Ci,j=Ai,j+Bi,jC_{i,j}=A_{i,j}+B_{i,j}Ci,j​=Ai,j​+Bi,j​ ，减法同理。 矩阵乘法： A∗B=CA*B=CA∗B=C 满足 Ci,j=∑k=1nAi,k∗Bk,jC_{i,j}=\\sum_{k=1}^{n}{A_{i,k}*B_{k,j}}Ci,j​=∑k=1n​Ai,k​∗Bk,j​ 矩阵乘法能够实现，仅当 AAA 的行数与 BBB 的列数相等时。 举个栗子： A={123123}A=\\begin{Bmatrix}1&amp;2&amp;3\\\\1&amp;2&amp;3\\\\\\end{Bmatrix}A={11​22​33​} ， B={321321}B=\\begin{Bmatrix}3&amp;2\\\\1&amp;3\\\\2&amp;1\\\\\\end{Bmatrix}B=⎩⎨⎧​312​231​⎭⎬⎫​ 那么对于 C=A∗BC=A*BC=A∗B ，则 C1,1=A1,1∗B1,1+A1,2∗B2,1+A1,3∗B3,1C_{1,1}=A_{1,1}*B_{1,1}+A_{1,2}*B_{2,1}+A_{1,3}*B_{3,1}C1,1​=A1,1​∗B1,1​+A1,2​∗B2,1​+A1,3​∗B3,1​ 简单来讲就是 C1,1=∑k=1n=3A1,k∗∑k=1m=3Bk,1C_{1,1}=\\sum_{k=1}^{n=3}{A_{1,k}}*\\sum_{k=1}^{m=3}{B_{k,1}}C1,1​=∑k=1n=3​A1,k​∗∑k=1m=3​Bk,1​ 那么矩阵乘法的代码实现即是： 矩阵快速幂： 对于一个矩阵 GGG 来说， GkG^kGk 中 Gi,jG_{i,j}Gi,j​ 的含义为从 iii 走到 jjj 步数为 kkk 的方案数。 不用理解太多，就是用矩阵实现快速幂即可，将数乘换成矩阵乘法（蒟蒻改了一下午，才发现把 iii 打成了 jjj） LuoguP3390 AC Code： ","link":"https://violeteternal.github.io/post/xue-xi-bi-ji-ju-zhen/"},{"title":"【学习笔记】同余","content":"同余： 定义： aaa 与 bbb 同余，当且仅当 aaa 与 bbb 除以 ppp 的余数相同，记作 aaa 与 bbb 模 ppp 同余，写作 a≡b(modp)a \\equiv b \\pmod pa≡b(modp)。 同余的性质： 若 a≡b(modp)a \\equiv b \\pmod pa≡b(modp) ，则有 a+c≡b+c(modp)a+c \\equiv b+c \\pmod pa+c≡b+c(modp) 若 a≡b(modp)a \\equiv b \\pmod pa≡b(modp) ，则有 ac≡bc(modp)ac \\equiv bc \\pmod pac≡bc(modp) 若 a≡b(modp)a \\equiv b \\pmod pa≡b(modp) ，且 c≡d(modp)c \\equiv d \\pmod pc≡d(modp) ，则有 a±c≡b±d(modp)a \\pm c \\equiv b \\pm d \\pmod pa±c≡b±d(modp) 若 ac≡bc(modp)ac \\equiv bc \\pmod pac≡bc(modp) ，且 (c,m)=1(c,m)=1(c,m)=1 ，那么 a≡b(modp)a \\equiv b \\pmod pa≡b(modp) 若 a≡b(modp)a \\equiv b \\pmod pa≡b(modp) ，且 c≡d(modp)c \\equiv d \\pmod pc≡d(modp) ，则有 ac≡bd(modp)ac \\equiv bd \\pmod pac≡bd(modp) 若 a≡b(modp)a \\equiv b \\pmod pa≡b(modp) ，则有 ac≡bc(modpc)ac \\equiv bc \\pmod {pc}ac≡bc(modpc) 若 aaa 和 bbb 都是整数，且 ddd 和 mmm 都是正整数， ddd 是 a,b,ma,b,ma,b,m 中任一公因数，则如果 a≡b(modm)a \\equiv b \\pmod ma≡b(modm) 成立时，则有 ad≡bd(modpd)\\frac{a}{d} \\equiv \\frac{b}{d} \\pmod {\\frac{p}{d}}da​≡db​(moddp​) 若 aaa 和 bbb 都是整数，且 ddd 和 mmm 都是正整数，且 d∣md|md∣m，则如果 a≡b(modm)a \\equiv b \\pmod ma≡b(modm) 成立时，则有 a≡b(modd)a \\equiv b \\pmod da≡b(modd) 。 若 aaa 和 bbb 都是整数，且 ddd 和 mmm 都是正整数，如果 a≡b(modm)a \\equiv b \\pmod ma≡b(modm) 成立时，则有 (a,m)=(b,m)(a,m)=(b,m)(a,m)=(b,m) ，且若如果 ddd 能够整除 a,b,ma,b,ma,b,m 中的任意一个， ddd 也就能整除 a,ba,ba,b 中的另一个。 扩展欧几里得算法： 若 (a,b)=d(a,b)=d(a,b)=d ，那么对于方程 ax+by=dax+by=dax+by=d 的解有一组特殊解为 x=x0,y=y0x=x_0,y=y_0x=x0​,y=y0​ ，那么该方程的通解为 x=x0+bd∗t,y=y0−ad∗tx=x_0+\\frac{b}{d}*t,y=y_0-\\frac{a}{d}*tx=x0​+db​∗t,y=y0​−da​∗t ，而我们用这个通解来逆向推出 gcdgcdgcd ，因为我们有欧几里得定理： (a,b)=d(a,b)=d(a,b)=d ，则有 (b,a mod b)=d(b,a \\bmod b)=d(b,amodb)=d 那么就会推出： d=a∗y1+b∗(x1−y1∗ab)d=a*y_1+b*(x_1-y_1*\\frac{a}{b})d=a∗y1​+b∗(x1​−y1​∗ba​) 在这个算式中满足： x=y1,y=x1−ab∗y1x=y_1,y=x_1-\\frac{a}{b}*y_1x=y1​,y=x1​−ba​∗y1​ 扩欧解同余方程： 对于方程 ax≡1(modb)ax \\equiv 1 \\pmod bax≡1(modb) ，已知 aaa 与 bbb ，求出最小的 xxx 。 LuoguP1082 妥妥的扩欧模板题： 中国剩余定理： LuoguP1495曹冲养猪 有一个同余方程组满足 {x≡a1(modm1)x≡a2(modm2)x≡a3(modm3)x≡a4(modm4)x≡a5(modm5)......x≡ak(modmk)\\left\\{\\begin{matrix}x \\equiv a_1 \\pmod {m_1} \\\\x \\equiv a_2 \\pmod {m_2} \\\\x \\equiv a_3 \\pmod {m_3} \\\\x \\equiv a_4 \\pmod {m_4} \\\\x \\equiv a_5 \\pmod {m_5} \\\\...... \\\\x \\equiv a_k \\pmod {m_k} \\end{matrix}\\right.⎩⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎧​x≡a1​(modm1​)x≡a2​(modm2​)x≡a3​(modm3​)x≡a4​(modm4​)x≡a5​(modm5​)......x≡ak​(modmk​)​ ，求出最小的 xxx 。 思路： 设 M=m1m2m3...mkM=m_1m_2m_3...m_kM=m1​m2​m3​...mk​ ，令 Mi=MmiM_i=\\frac{M}{m_i}Mi​=mi​M​ ，tit_iti​ 是 MiM_iMi​ 的逆元，有 Miti≡1(modm)iM_it_i \\equiv 1 \\pmod m_iMi​ti​≡1(modm)i​ 则 x=∑i=1kaiMitix=\\sum_{i=1}^{k}{a_iM_it_i}x=∑i=1k​ai​Mi​ti​ 则可构造特殊解 x0=x+k∗Mx_0=x+k*Mx0​=x+k∗M 最小正整数解即为 xmin=x0 mod Mx_{min}=x_0 \\bmod Mxmin​=x0​modM P3868 AC Code: 头图来源： Bilibili Undertale同人AU DigitFault ","link":"https://violeteternal.github.io/post/xue-xi-bi-ji-tong-yu-andju-zhen/"},{"title":"【题解】NOIP2022.01.26模拟赛","content":"题目I——集合均值(mos) MOS=Mean Of Set 一道完美的数学题，指不推公式你完全不知道它居然求的是**（暂且保密）。 因为每一次都需要从B中随机一个数，那么第一次取到了 aia_iai​ 的话，求到的 ansansans 应该加上 ai2\\frac{a_i}{2}2ai​​ ，以此类推，当第二次取到了 aja_jaj​ 的时候，求到了 ansansans 就取到 ai+aj3\\frac{a_i+a_j}{3}3ai​+aj​​ ，然后继续计算，我们会发现 BBB 中的所有数对最终答案的贡献系数都是一样的，并且其贡献系数与其在 BBB 中的位置没有关系，只会和 BBB 的大小有关系，然后继续推算，答案就显而易见了： ans=f(∣B∣)∑x∈Baans=f(|B|)\\sum_{x\\in B}{a}ans=f(∣B∣)∑x∈B​a 那么现在的问题就在于求出 f(i)f(i)f(i) 了，我们可以模拟从 BBB 移动到 AAA 的过程，花费 OmO{m}Om 的时间，这也是 40pt40pt40pt 的做法。然而这道题的关键在于：我们最后求出的期望值是一个有理数 fracabfrac{a}{b}fracab ，所以我们需要进行有理数取余，而进行逆元操作。（逆元便是这道题的正解） 怎么想到使用逆元的： 首先，我们已经推出了 ans=f(∣B∣)∑x∈Baans=f(|B|)\\sum_{x\\in B}{a}ans=f(∣B∣)∑x∈B​a ，设 iii 为当前 AAA ，即已经已过去了的数的个数，那么 ∣B∣=i−1i|B|=\\frac{i-1}{i}∣B∣=ii−1​ 了。我们需要在计算的过程中取模，也就自然想到使用逆元了。（虽然考的时候完全没有想到） 具体来说： 暴力模拟求逆元可得 70pt70pt70pt 线性求逆元可得 100pt100pt100pt 事实上，我们需要的也是这些逆元的和即可，根据原作者的话来说，会有一种强力的的多项式高科技能使求逆元的复杂度达到 O(nmlog⁡nm)O(\\sqrt{nm}\\log{nm})O(nm​lognm) 。但在这道题来说(n∗m≦2∗107n*m ≦ 2*10^7n∗m≦2∗107)，线性求逆元已经完全足够了。 Task One Ac Code: 题目II——聚烷撑乙二醇(pag) PAG=Play A Game 做题最大的收获是知道了 PAGPAGPAG 是聚烷撑乙二醇的意思 题目含义： 鲁迅曾经说过，要多去尝试，才能最终发现最优的答案。 鲁迅也还说过，要珍惜当下，把握住眼前的机会。 有 nnn 个随机数生成器，第 iii 个生成器可以均匀随机地生成 [Li,Ri][L_i,R_i][Li​,Ri​] 内的一个实数。 现在你要玩个游戏，从第 111 个生成器到第 nnn 个生成器，每次当前生成器会生成一个数，你需要选择： 相信鲁迅，拿走这个数，游戏结束。 相信鲁迅，放弃这个数和这个生成器，使用下一个生成器（前提是下一个生成器必须存在）。 求使用使得期望答案最大的策略时，期望答案是多少。 很玄学的题意和标题 思路详解： 其实想明白后十分简单，主要是想到这道题到底是怎样操作的。假设现在我们到了第 iii 的随机数生成器，第二个生成器产生的数的期望是 Y=Li+1+Ri+12Y=\\frac{L_{i+1}+R_{i+1}}{2}Y=2Li+1​+Ri+1​​ 。如果第 iii 个生成器产生了 XXX ，当 X&lt;YX&lt;YX&lt;Y 时，我们当然放弃 XXX 更优，反之则取出 XXX 。 那我们将 iii 与 i+1i+1i+1 扩展到 111 到 nnn 的思路。对于每一组来说，我们都这样来扩展答案，就可以得到下面的算式： 当 ans&lt;Lians&lt;L_ians&lt;Li​ 时 ans=Li+Ri2ans=\\frac{L_i+R_i}{2}ans=2Li​+Ri​​ 当 Li&lt;ans&lt;RiL_i&lt;ans&lt;R_iLi​&lt;ans&lt;Ri​ 时 ans=ans∗(ans−Li)+ans+Ri2∗(Ri−ans)Ri−Lians=\\frac{ans*(ans-L_i)+\\frac{ans+R_i}{2}*(R_i-ans)}{R_i-L_i}ans=Ri​−Li​ans∗(ans−Li​)+2ans+Ri​​∗(Ri​−ans)​ 否则， ans=ansans=ansans=ans ，当然，这步不用在代码里体现。 明白这件事之后，还有一个需要注意的，那就是： 我们在扩展答案是应该从 NNN 到 111 扩展： 因为我们只有在知道了 i+1i+1i+1 的区间之后才能知道第 iii 个到底取不取。 Task Two Ac Code： 头图来源： Warma ","link":"https://violeteternal.github.io/post/ti-jie-noip20220126-mo-ni-sai/"},{"title":"【题解】P1144 最短路计数","content":"题目链接： 最短路计数 题目概述&amp;解题思路： 字面意思，不多做解释。求出所有的最短路个数，对 106+310^6+3106+3 取模。当然，如果起点到编号为 iii 的点不连通当然数目就为0啦。 对于简单的思路，那就是跑出最短路，再跑一遍遍历，看有多少种情况能够走到 iii 点，然后统计。但是这样是绝对会超时的 对于 100100%100 的数据, N≦1000000,M≦2000000N ≦ 1000000,M ≦ 2000000N≦1000000,M≦2000000 .所以我们应该选择 SPFA ，啊对，就是选择SPFA，有些算法死了，它还活着。 我们可以用一个数组 AnsLAnsLAnsL 来存储从 111 号点到第 iii 号点的最短路个数，然后一边跑 SPFASPFASPFA 一边修改 AnsLAnsLAnsL 的值，即当我们当前从 uuu 点跑到了 vvv 点的话费与 DistvDist_vDistv​ 的值相同时，那么现在是一条目前找到的最短路（之后可能会存在更短路），那么就有： Ansv=Ansu+1Ans_v=Ans_u+1Ansv​=Ansu​+1 的推导公式。 而如果我们找到了更短路，那就把当前点的计数清零。从 uuu 点出发到的 vvv 点的路即是最短路（目前），则传递答案为： 这就是两种传递的方式，也就是本题最关键的代码核心。 其他的注意事项则在代码里体现： ","link":"https://violeteternal.github.io/post/ti-jie-p1144-zui-duan-lu-ji-shu/"},{"title":"【题解】UVA318 Domino Effect","content":"题解： 题目链接 这道题明明很简单我却被卡了很多次 说说这道题的思路： 题目很冗长，但其实理解下来很简单，不然为什么是黄题呢。 题意解释： 输入一个 NNN 个点， MMM 条边的无向图，每条边的起点，终点和权值。找出从编号为 111 的点能够到达的最远地点，这个地点可以在点上，也可以在边上。 对于这道题来说，最远的地方，只会有两种情况： *在某一个点上； *在某两点之间。 从起点 111 开始，对图上所有点走一遍最短路，找出到达最远的点，这就是第一种情况的答案，我们可以记录一次。然后将编号 222 至编号 NNN 的之间的全部点都跑一次，求出最远的边。 在这里，最朴素我刚开始想到的的方法就是求出到达两点的时间，然后根据时间差按比例分配这条边的权值，就是两边相遇的地点即时间。 但是， 实际上，换个角度思考，两组多米诺相遇的时间是一致的，所以从其中一点出发到另一点出发到的那个最远点时间一样，即是从起点到 iii 点加上起点到 jjj 点的距离再加上这条边的权值。这条边的最远时间就是： Valuei,j=(Disi+Disj+Pathi.j)/2Value_{i,j}=(Dis_i+Dis_j+Path_{i.j})/2Valuei,j​=(Disi​+Disj​+Pathi.j​)/2 上述即是对于答案的枚举，最坏情况为 O(N2)O(N^2)O(N2) ，这道题的 N≤500N≤500N≤500 完全足够。 最短路板块： 对于像我这种蒟蒻来说，有 333 种方法： Floyd： 通过考虑最佳子路径来得到最佳路径。单独一条边的路径也不一定是最佳路径。从任意一条单边路径开始。所有两点之间的距离是边的权的和，(如果两点之间没有边相连,则为 INFINFINF ）。从第一个顶点开始，依次将每个顶点作为媒介 kkk ，然后对于每一对顶点 uuu 和 vvv ，查看其是否存在一条经过 kkk 的，距离比已知路径更短的路径，如果存在则更新它。 Floyd的时间复杂度为 O(N3)O(N^3)O(N3) ，这种算法其实是拿来求全源最短路的，但放在单源最短路的题里依然使用，还是因为数据太小，所以可以选择。 SPFA已经死了： SPFA其实是另一种最短路算法Bellman-Ford的队列优化，但我们一般不使用。（因为太蒻了） 实际上，SPFA的实现与BFS相差无异。不同的是BFS中一个点如果出了队列就不再会进入队列，而在SPFA中如果一个点出了队列，它还有机会能够进入队列。因为一个点在对别的点进行松弛操作时，自己的最小值也同样会被自己修改过的点再次修改。 SPFA的复杂度并不是很稳定，最坏情况为 O(NM)O(NM)O(NM) 。 一般来说，随机数据的题SPFA和Dijkstra无异，但一般来说，有负权的图使用SPFA，因为Dijkstra不能处理负边权；而在一些毒瘤题里，就会出现关于SPFA…… 代码如下： 这道题过了最多的正解——Dijkstra： Dijkstra算法采用的是一种贪心的策略，建立一个数组 disdisdis 来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合： TTT ，初始时，原点s的路径权重被赋为 000 （即 diss=0dis_s=0diss​=0 ）。 若对于顶点 sss存在能直接到达的边 (s,m)(s,m)(s,m) ，则把 dismdis_mdism​设为 w(s,m)w(s,m)w(s,m) ,同时把所有其他（ sss 不能直接到达的）顶点的路径长度设为无穷大。 初始时，集合顶点 sss 。 然后，从 disdisdis 数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到 TTT 中，此时完成一个顶点。 然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短——如果是，那么就替换这些顶点在dis中的值；然后，又从 disdisdis 中找出最小值，重复上述动作，直到 TTT 中包含了图的所有顶点。 这就是Dijkstra的基本思路，但是在深度学习之后，我们一般使用的是Dijkstra的二叉堆（优先队列）优化： 而对于最短路来说，我们需要的是小根堆，优先队列初始大根堆。所以我们要重载一次。 结构体定义如下： 这道题的其他注意事项： *因为有多组数据，所以记得初始化所有相关变量 *多米诺的英文复数加的是 eseses！！！ *输出格式严格按照题目要求，句子后有两个 \\n\\n 补充一点我的代码风格： *我喜欢自己重写一些简单的函数代替STL库：maxmaxmax，minminmin，sortsortsort *每一个函数名之前都会加入一个类似于水印作用的标识符under，所以copy的同学记得删掉，而对于under的含义，请移步Undertale 蒟蒻第一篇题解，求过QWQ，并厚颜无耻的要波赞。 给上Dijkstra的AC代码： ","link":"https://violeteternal.github.io/post/ti-jie-uva318-domino-effect/"},{"title":"【学习笔记】欧拉函数","content":"定义： 指的是满足小于等于NNN且与NNN互质的数目和。 欧拉公式求解公式： 对于一个正整数NNN满足： φ(x)=∑k[(k,n)=1][k∈N][k&lt;n]\\varphi(x)=\\sum_{k}[(k, n)=1][k \\in N][k&lt;n]φ(x)=∑k​[(k,n)=1][k∈N][k&lt;n] 则有 φ(n)=n(1−1p1)(1−1p2)(1−1p3)⋯(1−1pk)\\varphi(n)=n\\left(1-\\frac{1}{p_{1}}\\right)\\left(1-\\frac{1}{p_{2}}\\right)\\left(1-\\frac{1}{p_{3}}\\right) \\cdots\\left(1-\\frac{1}{p_{k}}\\right)φ(n)=n(1−p1​1​)(1−p2​1​)(1−p3​1​)⋯(1−pk​1​) 欧拉函数的性质： 当N=0N=0N=0时： φ(0)=0\\varphi(0)=0φ(0)=0. 当N=1N=1N=1时： φ(1)=1\\varphi(1)=1φ(1)=1.因为1与自身互质。 当NNN为质数时： φ(N)=N−1\\varphi(N)=N-1φ(N)=N−1. 如果PPP是质数，而NNN是PPP的正整数次方： φ(PN)=PN(1−1p)\\varphi(P^N)=P^N(1-\\frac{1}{p})φ(PN)=PN(1−p1​) 欧拉定理： 设a,m∈N+a,m \\in N^+a,m∈N+，且(a,m)=1(a,m)=1(a,m)=1，那么则有 aφ(m)≡1(modm)a^{\\varphi(m)} \\equiv 1 \\pmod maφ(m)≡1(modm) 且aaa对模mmm的阶δm(a)\\delta_m(a)δm​(a)必须整除φ(a)\\varphi(a)φ(a). 证明： 取模mmm的缩系，a1,a2,a3......aφ(m)a_1,a_2,a_3......a_{\\varphi(m)}a1​,a2​,a3​......aφ(m)​， 则aa1,aa2,aa3......aaφ(m)aa_1,aa_2,aa_3......aa_{\\varphi(m)}aa1​,aa2​,aa3​......aaφ(m)​也是mmm的缩系. 故有∏i=1φ(m)ai≡∏i=1φ(m)aai≡aφ(m)∏i=1φ(m)ai(modm)\\prod_{i=1}^{\\varphi(m)}a_i \\equiv \\prod_{i=1}^{\\varphi(m)}aa_i \\equiv a^{\\varphi(m)}\\prod_{i=1}^{\\varphi(m)}a_i \\pmod m∏i=1φ(m)​ai​≡∏i=1φ(m)​aai​≡aφ(m)∏i=1φ(m)​ai​(modm) 则可以推出aφ(m)≡1(modm)a^{\\varphi(m)} \\equiv 1 \\pmod maφ(m)≡1(modm). 证毕 欧拉定理可以推出费马小定理： 如果p是一个质数，而整数aaa不是ppp的倍数， 则有a(p−1)≡1(modp)a^{(p-1)} \\equiv 1 \\pmod pa(p−1)≡1(modp)。 ","link":"https://violeteternal.github.io/post/xue-xi-bi-ji-ou-la-han-shu/"},{"title":"【学习笔记】线段树","content":"线段树是用来维护区间权值的一种数据结构，根据同机房巨佬而言，一般需要使用线段树的题考点都不在线段树上，不过线段树真滴好用 线段树的操作： Ⅰ.建树 我的习惯为使用结构体存储（就和链式前向星一样），也可以分开打： 一般来说，线段树的数组需要开四倍 NNN 空间，因为他比线性结构要多一层，而开四倍一般不会爆。 代码讲解： 对于其中之一 Tree[p]Tree[p]Tree[p] 中： lll 表示第p个编号所表示的区域起点为原线性结构的 AlA_lAl​ ； rrr 表示第p个编号所表示的区域终点为原线性结构的 ArA_rAr​ ； 子节点保证： l=rl=rl=r ； datdatdat 表示该区域的一个数据，一般视题目而定，且 datdatdat 的个数也不定。 tagtagtag 可有也可不有（如果是区间修改的题一般都有），表示“懒惰标记”，之后详解。 ppp 结点的子结点为 p∗2p*2p∗2 和 p∗2+1p*2+1p∗2+1 ，一般在代码中写为 p&lt;&lt;1p&lt;&lt;1p&lt;&lt;1 和 p&lt;&lt;1∣1p&lt;&lt;1|1p&lt;&lt;1∣1 来节约时间（因为位运算时间复杂度＜乘法复杂度） 建树一般使用递归建树： Ⅱ.查询 以查询该区间权值和为例： 如果该结点在需要查询的区间内，返回该点权值； 如果不在搜索子结点，如果需要的 lll 比该结点的 midmidmid 小，则搜索 (l,mid)(l,mid)(l,mid)；如果需要的 rrr 比该结点的 midmidmid 大，则搜索(mid+1,r)(mid+1,r)(mid+1,r)。 具体操作看函数： Ⅲ.单点修改 找到该点的编号，从下至上修改它的所有父结点直到，依然使用递归操作。 datdatdat 存储该区间的区间和： Ⅳ.向上传递（pushup） 即函数underPushUp，一般都是视题目而定。 以区间和为例： 似乎这个例子没什么说服力，不过的确是这样的。 Ⅴ.向下传递（pushdown/spread） 只限于懒惰标记。当我们需要改变该区间中的子区间才会向下传递，这样可以优化时间，否则每一次区间修改都会花费 O(N)O(N)O(N) 的时间复杂度。 依然以区间和为例： Ⅵ.区间修改 使用懒惰标记，可以让时间复杂度降到 O(logN)O(logN)O(logN) 。 依然以区间和为例： 一些练习 区间修改区间查找模板题 区间最大子段和模板题 P2574 XOR的艺术 区间求sin和，需要使用数学知识 卡常卡码风的毒瘤题 头图来源： Warma ","link":"https://violeteternal.github.io/post/xue-xi-bi-ji-xian-duan-shu/"}]}