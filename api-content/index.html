{"posts":[{"title":"【学习笔记】函数与极限","content":"在了解函数极限之前，我们需要知道一些概念。 资料参考：Dyd巨佬 拓扑空间 拓扑空间的邻域定义 设 XXX 是一个集合， Ux\\mathfrak{U}_xUx​ 为其子集族，其元称为 xxx 的邻域，令 U={Ux}x∈X\\mathfrak{U} = \\{ \\mathfrak{U}_x \\}_{x \\in X}U={Ux​}x∈X​ ，则 (X,U)( X , \\mathfrak{U})(X,U) 被称为一个拓扑空间。 邻域 邻域，是指集合上的一种基础的拓扑结构。 对于实数 α,δ\\alpha , \\deltaα,δ ： 定义数集 {x∈R∣a−δ&lt;x&lt;a+δ}\\{x \\in R \\mid a - \\delta &lt; x &lt; a + \\delta\\}{x∈R∣a−δ&lt;x&lt;a+δ} 为 aaa 以 δ\\deltaδ 为半径的邻域，记做 U(a,δ)U(a, \\delta)U(a,δ) 定义数集 {x∈R∣a−δ&lt;x&lt;a或a&lt;x&lt;a+δ}\\{x \\in R \\mid a - \\delta &lt; x &lt; a 或 a &lt; x &lt; a + \\delta\\}{x∈R∣a−δ&lt;x&lt;a或a&lt;x&lt;a+δ} 为 aaa 以 δ\\deltaδ 为半径的去心邻域，记做 U˚(a,δ)\\mathring{U}(a, \\delta)U˚(a,δ) 定义数集 {x∈R∣a−δ&lt;x&lt;a}\\{x \\in R \\mid a - \\delta &lt; x &lt; a\\}{x∈R∣a−δ&lt;x&lt;a} 为 aaa 以 δ\\deltaδ 为半径的去心左邻域，记做 U˚−(a,δ)\\mathring{U} _- (a, \\delta)U˚−​(a,δ) 定义数集 {x∈R∣a&lt;x&lt;a+δ}\\{x \\in R \\mid a &lt; x &lt; a + \\delta\\}{x∈R∣a&lt;x&lt;a+δ} 为 aaa 以 δ\\deltaδ 为半径的去心右邻域，记做 U˚+(a,δ)\\mathring{U} _+ (a, \\delta)U˚+​(a,δ) 函数的左极限和右极限统称为侧边极限 明显， lim⁡x→x0+f(x)=a\\lim \\limits _{x \\to {x _0} _+} f(x) = ax→x0​+​lim​f(x)=a 且 lim⁡x→x0−f(x)=a\\lim \\limits _{x \\to {x _0} _-} f(x) = ax→x0​−​lim​f(x)=a 与 lim⁡x→x0f(x)=a\\lim \\limits _{x \\to x _0} f(x) = ax→x0​lim​f(x)=a 互为充要条件 性质 唯一性 若 f(x)→a(x→r)f(x) \\to a(x \\to r)f(x)→a(x→r) 且 f(x)→b(x→r)f(x) \\to b (x \\to r)f(x)→b(x→r) ，则 a=ba = ba=b 局部有界 若在某一个过程时 f(x)f(x)f(x) 有极限，则存在一个时刻以后 f(x)f(x)f(x) 有界。 即若极限 lim⁡x→x0f(x)\\lim \\limits_{x \\to x_0} f(x)x→x0​lim​f(x) 存在，则函数 f(x)f(x)f(x) 在 x0x_0x0​ 的某一空心邻域上有界。 局部保号性 若 lim⁡x→x0f(x)=A\\lim \\limits_{x \\to x_0} f(x) = Ax→x0​lim​f(x)=A ，且 A&gt;0A &gt; 0A&gt;0 ，则 ∃δ&gt;0\\exists \\delta &gt; 0∃δ&gt;0 ，当 x∈U0(x0,δ)x \\in U^0 ( x_0 , \\delta )x∈U0(x0​,δ) 时， $ f(x)&gt;0 $ 。 迫敛性 如果函数 f(x),g(x),h(x)f(x),g(x),h(x)f(x),g(x),h(x) 满足： g(x)≤f(x)≤h(x)g(x) \\leq f(x) \\leq h(x)g(x)≤f(x)≤h(x) lim⁡g(x)=A,lim⁡h(x)=A\\lim g(x) = A , \\lim h(x) = Alimg(x)=A,limh(x)=A 那么 lim⁡f(x)\\lim f(x)limf(x) 存在且为 AAA 。 ","link":"https://violeteternal.github.io/post/xue-xi-bi-ji-han-shu-yu-ji-xian/"},{"title":"【题解】NOIP2022.02.12模拟赛","content":"题目I——城墙（wall） 题目描述 给出一个长度为 nnn 的序列和一个数 SSS ，求出最短的区间使得区间和大于等于 SSS 。 思路 因为 n≤1500000n \\leq 1500000n≤1500000 ，所以复杂度最大为 O(nlog⁡n)O(n \\log n)O(nlogn) ，统计前缀和，二分统计长度是否能达到，每次暴力区间和。复杂度合适。 Task One AC Code 题目II——岗哨（sentry） 题目含义： 给出一个长度为 n(n≤106)n(n \\leq 10^6)n(n≤106) 的序列： 第一个答案求的是一段最长的，严格递增的，右端点最小的子区间，输出该子区间的右端点。 第二行答案求的是去掉一个区间后，一段最长的，严格递增的，右端点最小的子区间，输出该子区间的右端点和长度。 其他事项 洛谷有一道类似题目——UVA1471防线 根据机房老大哥的教导，这道题的方法多样：树状数组，线段树，DpDpDp，离散化等。 思路 注：本人的线段树写挂了，所以以下方法来自同机房巨佬Live的题解 对于第一个答案，用 numinum_inumi​ 结构体统计每一个连续上升子区间的信息，得出最大的子区间长度，输出右端点即可。 对于第二个答案，用 fif_ifi​ 统计以 iii 为起点的最长上升子序列的大小， gig_igi​ 来统计以 iii 结尾的最长上升子序列的大小。枚举 ai,i∈(1,n)a_i , i \\in ( 1 , n )ai​,i∈(1,n) ，找到每一个 kkk 使 ak&lt;aia_k &lt; a_iak​&lt;ai​ 时的 gk+fig_k + f_igk​+fi​ 最大。 这样子看来，这个模拟的过程类似于求 LISLISLIS （最长上升子序列）的过程。以 bib_ibi​ 数组存储能够使 gig_igi​ 的值为 iii 的最小的 aia_iai​ 的值。最后我们求到的 dpdpdp 位置是第二个区间的左端点，所以最后输出的应该是 dp+fdp−1dp+f_{dp}-1dp+fdp​−1 的位置。 Task Two AC Code 题目III——黑客（Hack） 题目含义 给定一个有向图，从任意一点出发遍历所有点，删除所有经过的边；再从任意一点出发遍历所有点，如果能达到，求出两次所需的最小权值和。 思路 说实话，当看到 n≤10,m≤25n \\leq 10 , m \\leq 25n≤10,m≤25 时我真的以为正解是爆搜。然而测试数据有 100010001000 套。 跑一遍最小生成树（建议 KruskalKruskalKruskal ），求出这棵树上的必要边（删掉会使原图最小生成树的总权值变大的边）。这些边必在第二棵最小生成树里。枚举必要边在 AAA 和 BBB 生成树里的情况，则 ans=min⁡(a+b)ans = \\min ( a + b )ans=min(a+b) 。 可惜蒟蒻到最后也没打出来qwq Task Three AC Code 题目IV——膜拜大会（fake） 过于毒瘤，不会qwq 给一个链接 ","link":"https://violeteternal.github.io/post/ti-jie-noip20220212-mo-ni-sai/"},{"title":"【学习笔记】数列与极限 #2","content":"实数的完备性定理（部分） 单调有界定理 若数列 {xn}\\{ x_n \\}{xn​} 递增且有上界，则 lim⁡n→+∞xn=sup⁡{xn∣n∈N}\\lim \\limits_{n \\to +\\infty} x_n = \\sup \\{ x_n | n \\in N \\} n→+∞lim​xn​=sup{xn​∣n∈N} 若数列 {xn}\\{ x_n \\}{xn​} 递减且有下界，则 lim⁡n→+∞xn=inf⁡{xn∣n∈N}\\lim \\limits_{n \\to +\\infty} x_n = \\inf \\{ x_n | n \\in N\\} n→+∞lim​xn​=inf{xn​∣n∈N} 柯西收敛原理 设 $ { x_n } $ 是一个数列，如果对于任意一个 ϵ&gt;0\\epsilon &gt; 0ϵ&gt;0 ，存在 N∈Z∗N \\in \\mathbb{Z^*}N∈Z∗ ，只要 nnn 满足 n&gt;Nn &gt; Nn&gt;N ，则对于任意正整数 ppp 而言，都有 ∣xn+p−xn∣&lt;ϵ| x_{n+p}-x_n | &lt; \\epsilon∣xn+p​−xn​∣&lt;ϵ ，这样的数列 {xn}\\{ x_n \\}{xn​} 便称为柯西数列。 这样的渐进稳定性和收敛性是等价的，即为充分必要条件。 简单来说： 数列{xn}收敛的充要条件是∀ϵ∈R+,∃N∈Z+,∀n,m&gt;N(∣xm−xn∣&lt;ϵ)数列 \\{ x_n \\} 收敛的充要条件是 \\forall \\epsilon \\in \\mathbb{R^+} , \\exists N \\in \\mathbb{Z^+} , \\forall n,m &gt; N ( | x_m - x_n | &lt; \\epsilon ) 数列{xn​}收敛的充要条件是∀ϵ∈R+,∃N∈Z+,∀n,m&gt;N(∣xm​−xn​∣&lt;ϵ) 戴德金原理 如果 R\\mathbb{R}R 的两个子集 AAA 和 BBB 满足： 1.A≠∅∧B≠∅2.A∪B=R3.∀x∈A,∀y∈B(x&lt;y)\\begin{aligned} &amp;1. A \\neq \\emptyset \\wedge B \\neq \\emptyset \\\\ &amp;2. A \\cup B = \\mathbb{R}\\\\ &amp;3. \\forall x \\in A , \\forall y \\in B ( x &lt; y ) \\\\ \\end{aligned} ​1.A​=∅∧B​=∅2.A∪B=R3.∀x∈A,∀y∈B(x&lt;y)​ 那么， ∃c∈R(∀a∈A,∀b∈B(a≤c≤b))\\exists c \\in \\mathbb{R} ( \\forall a \\in A , \\forall b \\in B ( a \\leq c \\leq b) )∃c∈R(∀a∈A,∀b∈B(a≤c≤b)) 。 闭区间套定理 如果数列 {an}\\{ a_n \\}{an​} 和 {bn}\\{ b_n \\}{bn​} 满足： 1.∀n∈Z+(an≤an+1&lt;bn+1≤bn)2.lim⁡n→+∞(bn−an)=0\\begin{aligned} &amp;1. \\forall n \\in \\mathbb{Z^+} ( a_n \\leq a_{n+1} &lt; b_{n+1} \\leq b_n ) \\\\ &amp;2. \\lim \\limits_{n \\to +\\infty} ( b_n - a_n ) = 0 \\\\ \\end{aligned} ​1.∀n∈Z+(an​≤an+1​&lt;bn+1​≤bn​)2.n→+∞lim​(bn​−an​)=0​ 那么以下结论成立： 1.lim⁡n→+∞an=lim⁡=n→+∞bn(该极限值记为c)2.上述c是满足∀n∈Z+(an≤c≤bn)的唯一实数\\begin{aligned} &amp;1. \\lim \\limits_{n \\to +\\infty} a_n = \\lim \\limits =_{n \\to +\\infty} b_n (该极限值记为 c )\\\\ &amp;2. 上述 c 是满足 \\forall n \\in \\mathbb{Z^+} ( a_n \\leq c \\leq b_n ) 的唯一实数 \\end{aligned} ​1.n→+∞lim​an​=lim=n→+∞​bn​(该极限值记为c)2.上述c是满足∀n∈Z+(an​≤c≤bn​)的唯一实数​ 确界存在原理 对于 R\\mathbb{R}R 的任何非空子集 SSS ，若 SSS 在 R\\mathbb{R}R 内有上界，则 SSS 在 R\\mathbb{R}R 内有上确界。 ","link":"https://violeteternal.github.io/post/xue-xi-bi-ji-shu-lie-yu-ji-xian-2/"},{"title":"【题解】CF451E Devus and Flowers","content":"题目传送门 注意 用费马小定理推答案，记得卡常和开 longlonglong longlonglong 。 AC Code： ","link":"https://violeteternal.github.io/post/ti-jie-cf451e-devus-and-flowers/"},{"title":"【题解】P3601 签到题","content":"题目传送门 思路 qiandao(x)=x−ϕ(x)qiandao ( x ) = x- \\phi (x)qiandao(x)=x−ϕ(x) 线性筛出 r=106\\sqrt{r} = 10^6r​=106 以内的质数，然后再 O(r−l)O(r-l)O(r−l) 暴力枚举每个质数 primeprimeprime ，接着统计每一个质数对区间内数字的 ϕx\\phi xϕx 的影响，再暴力求和。 AC Code： ","link":"https://violeteternal.github.io/post/ti-jie-p3601-qian-dao-ti/"},{"title":"【题解】P4035 球形空间产生器","content":"题目传送门 高斯消元。 AC Code： ","link":"https://violeteternal.github.io/post/ti-jie-p4035-qiu-xing-kong-jian-chan-sheng-qi/"},{"title":"【题解】P3200 有趣的数列","content":"题目传送门 思路 暴力出较小答案，发现这道题就是求 CatalanCatalanCatalan 数 f(n−2)f(n-2)f(n−2) 的值。 求卡特兰数 这道题只能使用 fn=C2nnn+1f_n=\\frac{C^n_{2n}}{n+1}fn​=n+1C2nn​​ ，拆分得 C2nnn+1=∏i=n+22ni∏i=1ni\\frac{C^n_{2n}}{n+1} = \\frac{\\prod^{2n}_{i=n+2}i}{\\prod^{n}_{i=1}i}n+1C2nn​​=∏i=1n​i∏i=n+22n​i​ ，那么我们将 2∗n2*n2∗n 范围内的质数筛出来，得到每个数最小的质因数，进行约分再使用快速幂得出结果。 AC Code： ","link":"https://violeteternal.github.io/post/ti-jie-p3200-you-qu-de-shu-lie/"},{"title":"【学习笔记】数列与极限","content":" 数学不能凭 sensesensesense ，必须要追求严谨。—— ZqZqZq 数列定义 一种从自然数（或正整数）到实数（或其它域）的映射 f:N→Rf : \\mathbb{N} \\to \\mathbb{R}f:N→R ，这便是一个数列。一般来说，设 an=f(n)a_n=f(n)an​=f(n) ，则该数列记作 {an}n=0+∞\\{ a_n \\}_{n=0}^{+ \\infty}{an​}n=0+∞​ 定义一个数列 f:N→Rf : \\mathbb{N} \\to \\mathbb{R}f:N→R 的子数列为一个数列 g:L→Rg : L \\to \\mathbb{R}g:L→R 满足 L⊆N∧∀n∈L,g(n)=f(n)∧∣L∣=+∞L \\subseteq \\mathbb{N} \\wedge \\forall n \\in L , g(n) = f(n) \\wedge \\mid L \\mid = + \\inftyL⊆N∧∀n∈L,g(n)=f(n)∧∣L∣=+∞ 。 极限 对于一个数列 {a_n\\}_{n = 1}^{+ \\infty } ，若 ∃δ∈R,s.t.∀ϵ&gt;0,∃N&gt;0∧N∈N+,s.t.∀n&gt;N,∣an−δ∣&lt;ϵ\\exists \\delta \\in R, s.t. \\forall \\epsilon &gt; 0, \\exists N &gt; 0 \\wedge N \\in \\mathbb{N}^+, s.t. \\forall n &gt; N , \\mid a_n - \\delta \\mid &lt; \\epsilon∃δ∈R,s.t.∀ϵ&gt;0,∃N&gt;0∧N∈N+,s.t.∀n&gt;N,∣an​−δ∣&lt;ϵ ，我们就称 δ\\deltaδ 为数列的极限，记作 lim⁡n→+∞an=δ\\lim\\limits _{n \\to + \\infty} a_n = \\deltan→+∞lim​an​=δ ，或者 an→δ(n→+∞)a_n \\to \\delta(n \\to + \\infty)an​→δ(n→+∞) ，有时候括号内的可以省略。（上面的 s.ts.ts.t 指 “使得”） 对于一个数列，如果它存在极限，我们就称这个数列收敛，否则就称其发散。 数列极限的几何意义 对于一个数列满足： 当n&gt;N时，均有不等式∣xn−a∣&lt;ϵ\\begin{aligned} 当 n &gt; N 时，均有不等式 | x_n - a | &lt; \\epsilon \\end{aligned} 当n&gt;N时，均有不等式∣xn​−a∣&lt;ϵ​ 即表示： 所有下标大于N的xn都落在(a−ϵ,a+ϵ)内，且落在(a−ϵ,a+ϵ)之外的点至多有N个（有限）\\begin{aligned} \\\\所有下标大于 N 的 x_n 都落在 ( a - \\epsilon , a + \\epsilon ) 内， \\\\且落在 ( a - \\epsilon , a + \\epsilon ) 之外的点至多有 N 个（有限） \\end{aligned} 所有下标大于N的xn​都落在(a−ϵ,a+ϵ)内，且落在(a−ϵ,a+ϵ)之外的点至多有N个（有限）​ 如果存在某个值 ϵ0\\epsilon_0ϵ0​ 使得数列 xn{x_n}xn​ 中有无穷个项落在 (a−ϵ0,a+ϵ0)( a - \\epsilon_0 , a+ \\epsilon_0)(a−ϵ0​,a+ϵ0​) 之外，则 xn{x_n}xn​ 一定不以 aaa 为极限。 数列极限的性质： 唯一性 若一个数列的极限存在，则极限值是唯一的，且它的任何子列的极限与原数列相等。 证明，即：若 an→b,an→ca_n \\to b, a_n \\to can​→b,an​→c 则 b=cb = cb=c 有： ∀ϵ&gt;0,∃Nb&gt;0,s.t.∀n&gt;Nb,∣an−b∣&lt;ϵ∀ϵ&gt;0,∃Nc&gt;0,s.t.∀n&gt;Nc,∣an−c∣&lt;ϵ\\begin{aligned} \\forall \\epsilon &gt; 0, \\exists N_b &gt; 0, s.t. \\forall n &gt; N_b, \\mid a_n - b \\mid &lt; \\epsilon \\\\ \\forall \\epsilon &gt; 0, \\exists N_c &gt; 0, s.t. \\forall n &gt; N_c, \\mid a_n - c \\mid &lt; \\epsilon \\\\ \\end{aligned} ∀ϵ&gt;0,∃Nb​&gt;0,s.t.∀n&gt;Nb​,∣an​−b∣&lt;ϵ∀ϵ&gt;0,∃Nc​&gt;0,s.t.∀n&gt;Nc​,∣an​−c∣&lt;ϵ​ 记 N=max⁡(Nb,Nc)N = \\max(N_b, N_c)N=max(Nb​,Nc​) 有： ∀n&gt;N,∣an−c∣+∣an−b∣&lt;2ϵ\\forall n &gt; N, \\mid a_n - c \\mid + \\mid a_n - b \\mid &lt; 2 \\epsilon ∀n&gt;N,∣an​−c∣+∣an​−b∣&lt;2ϵ 由三角不等式 ∣a∣−∣b∣≤∣a±b∣≤∣a∣+∣b∣\\mid a \\mid - \\mid b \\mid \\le \\mid a \\pm b \\mid \\le \\mid a \\mid + \\mid b \\mid∣a∣−∣b∣≤∣a±b∣≤∣a∣+∣b∣ 得： ∣b−c∣&lt;2ϵ\\mid b - c \\mid &lt; 2 \\epsilon ∣b−c∣&lt;2ϵ 由于 ϵ\\epsilonϵ 可以无限小，故有 b=cb = cb=c QED 有界性 如果一个数列收敛，则这个数列一定有界。 但如果一个数列有界，它不一定收敛 e.g.xn=(−1)ne.g. {x_n}=(-1)^ne.g.xn​=(−1)n 保号性 若 lim⁡n→+∞xn=a&gt;0\\lim \\limits_{n \\to +\\infty} x_n = a &gt; 0n→+∞lim​xn​=a&gt;0 （或 &lt;0&lt;0&lt;0 ） ，则对任何 m∈(0,a)(a&lt;0m \\in ( 0 , a )( a &lt; 0m∈(0,a)(a&lt;0 时则是 m∈(a,0)m \\in ( a , 0 )m∈(a,0) ，存在 N&gt;0N &gt; 0N&gt;0 ，使 n&gt;Nn &gt; Nn&gt;N 时有 xn&gt;Mx_n &gt; Mxn​&gt;M （相应的是 xn&lt;mx_n&lt;mxn​&lt;m ） 基本运算法则 若 CCC 为常数，则 lim⁡n→+∞C=C\\lim \\limits_{n \\to + \\infty} C = Cn→+∞lim​C=C 若 CCC 为常数，则 lim⁡n→+∞Cn=0\\lim \\limits_{n \\to + \\infty} \\frac{C}{n} = 0n→+∞lim​nC​=0 若 ∣a∣&lt;1| a | &lt; 1∣a∣&lt;1 ，则 lim⁡n→+∞an=0\\lim \\limits_{n \\to +\\infty} a^n = 0n→+∞lim​an=0 如果 lim⁡n→+∞an=A,lim⁡n→+∞bn=B\\lim \\limits_{n \\to +\\infty} a_n = A , \\lim \\limits_{n \\to + \\infty} b_n =Bn→+∞lim​an​=A,n→+∞lim​bn​=B 且 CCC 为常数。则： lim⁡n→+∞(an±bn)=A±Blim⁡n→+∞(an⋅bn)=A⋅B\\begin{aligned} \\\\ \\lim \\limits_{n \\to +\\infty} (a_n \\pm b_n) = A \\pm B \\\\ \\lim \\limits_{n \\to +\\infty} (a_n · b_n) = A · B \\end{aligned} n→+∞lim​(an​±bn​)=A±Bn→+∞lim​(an​⋅bn​)=A⋅B​ 子数列的极限 对于一个数列 {an}n=1+∞\\{a_n\\}{n = 1}^{+ \\infty}{an​}n=1+∞ 的子数列 {ank}k=1+∞\\{a{n_k}\\}{k = 1}^{+ \\infty}{ank​}k=1+∞ ，若 an→δa_n \\to \\deltaan​→δ ，则 ank→δa{n_k} \\to \\deltaank​→δ 证明： 对于所有 kkk ，有 nk≥kn_k \\ge knk​≥k ，又因为 ∀ϵ&gt;0,∃N&gt;0,s.t.∀n&gt;N,∣an−b∣&lt;ϵ\\forall \\epsilon &gt; 0, \\exists N &gt; 0, s.t. \\forall n &gt; N, \\mid a_n - b \\mid &lt; \\epsilon∀ϵ&gt;0,∃N&gt;0,s.t.∀n&gt;N,∣an​−b∣&lt;ϵ 故 ∀ϵ&gt;0\\forall \\epsilon &gt; 0∀ϵ&gt;0 ，取 K=NK = NK=N ，有 ∀k&gt;K,nk≥k&gt;K=N\\forall k &gt; K, n_k \\ge k &gt; K = N∀k&gt;K,nk​≥k&gt;K=N ，故 ∣ank−b∣&lt;ϵ\\mid a_{n_k} - b \\mid &lt; \\epsilon∣ank​​−b∣&lt;ϵ ，即 ank→δa_{n_k} \\to \\deltaank​​→δ QED 级数 级数是指将数列的项依次用加号连接起来的函数，用 OIerOIerOIer 的话来说就是数列的前缀和，即对于数列 {sn}n=1+∞\\{s _n\\} _{n = 1}^{+ \\infty}{sn​}n=1+∞​ ，有 sn=∑i=1nais _n = \\sum _{i = 1}^n a _isn​=∑i=1n​ai​ 数列的和 对于数列 {an}n=1+∞\\{a _n\\} _{n = 1}^{+ \\infty}{an​}n=1+∞​ ，它的和 ∑n=1+∞an\\sum _{n = 1}^{+ \\infty} a _n∑n=1+∞​an​ 有意义，当且仅当它的级数数列 {sn}n=1+∞\\{s _n\\} _{n = 1}^{+ \\infty}{sn​}n=1+∞​ 收敛 正确性显然 这里补充一个等比数列求和公式（设公比为 qqq ）： (1−q)(1+q+q2+…+qn)=1−qn+1(1 - q)(1 + q + q^2 + … + q^n) = 1 - q^{n + 1}(1−q)(1+q+q2+…+qn)=1−qn+1 极限的线性可加性 设 an→a,bm→ba_n \\to a, b_m \\to ban​→a,bm​→b ，则 lim⁡n→+∞(αan+βbn)=αa+βb\\lim \\limits _{n \\to + \\infty} (\\alpha a_n + \\beta b_n) = \\alpha a + \\beta bn→+∞lim​(αan​+βbn​)=αa+βb 证明： ∣αan+βbn−(αa+βb)∣≤∣α∣∣an−a∣+∣β∣∣bn−b∣=∣α∣ϵ‘+∣β∣ϵ‘\\begin{aligned} &amp; \\mid \\alpha a _n + \\beta b _n - (\\alpha a + \\beta b) \\mid \\\\ \\le &amp; \\mid \\alpha \\mid \\mid a _n - a \\mid + \\mid \\beta \\mid \\mid b _n - b \\mid \\\\ &amp; = \\mid \\alpha \\mid \\epsilon ‘ + \\mid \\beta \\mid \\epsilon ‘ \\end{aligned} ≤​∣αan​+βbn​−(αa+βb)∣∣α∣∣an​−a∣+∣β∣∣bn​−b∣=∣α∣ϵ‘+∣β∣ϵ‘​ 夹逼定理 设 an≤bn≤cna_n \\le b_n \\le c_nan​≤bn​≤cn​ ，且 lim⁡n→+∞an=lim⁡n→+∞cn\\lim \\limits _{n \\to + \\infty} a_n = \\lim \\limits _{n \\to + \\infty} c_nn→+∞lim​an​=n→+∞lim​cn​ ，则 lim⁡n→+∞an=lim⁡n→+∞bn\\lim \\limits _{n \\to + \\infty} a_n = \\lim \\limits _{n \\to + \\infty} b_nn→+∞lim​an​=n→+∞lim​bn​ ","link":"https://violeteternal.github.io/post/xue-xi-bi-ji-shu-lie-yu-ji-xian/"},{"title":"【题解】P4588 数学计算","content":"题目传送门 思路 以时间为轴建立线段树，叶子结点维护该操作时间的乘数，非叶子结点维护区间乘，叶子结点初始化为 111 。每次乘的时候进行单点修改，将该次操作时间的位置修改为该乘数，最后输出 dat1dat_1dat1​ AC Code： ","link":"https://violeteternal.github.io/post/ti-jie-p4588-shu-xue-ji-suan/"},{"title":"【题解】SP2713 and P4145","content":"双倍经验~ 上帝造题的七分钟 Can you answer these queries 区间开方操作，暴力修改。 技巧： 即使是最大的 101810^{18}1018 开方 666 次之后也会变为 111 。 记录当前区间已经改过的次数，大于 666 时则不需要了。 也可以记录区间最大值，若最大值小于等于 111 则不需要了。 P4145 AC Code： SP2713 AC Code： ","link":"https://violeteternal.github.io/post/ti-jie-sp2713andp4145/"},{"title":"【题解】P3166 数三角形","content":"题目传送门 思路 对于一个三角形，只要三点不共线就存在，那么我们就找共线的个数，减掉即可。 AC Code： ","link":"https://violeteternal.github.io/post/ti-jie-p3166-shu-san-jiao-xing/"},{"title":"【题解】P1350 车的放置","content":"题目传送门 思路 DP 状态转移 首先将所构成的图左右翻转（方便 DPDPDP ） fj,if_{j,i}fj,i​ 表示前 jjj 列里放 iii 个的方案数； vjv_jvj​ 表示第 jjj 列的高度； 转移方程： fj,i=(fj−1,i+fj−1,i−1∗(vj−i+1)) mod (105+3)f_{j,i}=(f_{j-1,i}+f_{j-1,i-1}*(v_j-i+1)) \\bmod (10^5+3)fj,i​=(fj−1,i​+fj−1,i−1​∗(vj​−i+1))mod(105+3) 答案： fa+c,kf_{a+c,k}fa+c,k​ AC Code： ","link":"https://violeteternal.github.io/post/ti-jie-p1350-che-de-fang-zhi/"},{"title":"【题解】P1771 方程的解","content":"题目传送门 思路 计算 g(x)g(x)g(x) 使用快速幂，时间复杂度 O(log⁡n)O(\\log n)O(logn) 推导答案 过程略，得到答案即为 Cg(x)−1k−1C^{k-1}_{g(x)-1}Cg(x)−1k−1​ ，也是杨辉三角第 g(x)g(x)g(x) 行的第 kkk 个数。 高精度求答案即可 AC Code： ","link":"https://violeteternal.github.io/post/ti-jie-p1771-fang-cheng-de-jie/"},{"title":"【题解】P3193 GT考试","content":"题目传送门 预处理 DPDPDP 数组的 KMPKMPKMP 预配指针，再矩阵快速幂求出所有的集合。 使用闫氏DP分析法可得 fff 数组的集合意义。 AC Code： ","link":"https://violeteternal.github.io/post/ti-jie-p3193-gt-kao-shi/"},{"title":"【学习笔记】闫氏DP分析法","content":"原作指路 “所有的 DPDPDP 问题，本质上都是有限集中的最值问题”——闫老师 核心思想 从集合的方式来考虑 DPDPDP 的状态。 阶段 DPDPDP 的阶段：状态和状态转移。 所以有：状态表示和状态计算。 状态表示 把几个具有相同点的元素合在一起考虑，成为一个状态 对于一个状态 FiF_iFi​ ，考虑两个角度： 1.集合： f(i)f(i)f(i) 表示什么集合 由于 FiF_iFi​ 表示的是一堆东西(这也是 DPDPDP 优于枚举的核心)，我们要考虑这一堆东西的共同特征，如：所有满足某个条件的元素集合。这一点请仔细考虑，到底是大于等于，大于，小于，小于等于，等于......这些的不同会导致状态计算方式的不同 2.属性： f(i)f(i)f(i) 的属性 存的数与集合的关系：如 max,min,count,summax,min,count,summax,min,count,sum 等。 很明显， FiF_iFi​ 大多数时候是一个数，代表这个集合的某一个属性，多是最大值、最小值、数量、总和等。题目问什么，属性一般就是什么。 状态计算 对于 FiF_iFi​ 所表示的集合，我们将其划分为多个子集。 划分的依据——找最后一个不同点（依题而定，即关键决策） 划分之后，根据其子集求 FiF_iFi​ 的值。 举例：当属性为 maxmaxmax 时， Fi=max(F_i=max(Fi​=max( 子集的 max)max)max) ，当属性为 countcountcount 时， Fi=∑(F_i=\\sum(Fi​=∑( 子集的 count)count)count) 等。 其他链接 IzayoiMiku XinyueRao AcWing ","link":"https://violeteternal.github.io/post/xue-xi-bi-ji-yan-shi-dp-fen-xi-fa/"},{"title":"【题解】P1462 通往奥格瑞玛的道路","content":"题目链接： 传送门 题解大意： 对于一道有着两个限制条件（即血量与金钱）的图论搜索题，首选BFS 开玩笑的啦，BFS这道题铁定会超，无论空间还是时间。 二分价格，看在血量够的情况下是否能到达终点。 时间复杂度： 二分： O(log109)O(log10^9)O(log109) SPFA： O(kn)O(kn)O(kn) 稳稳地不会超 AC Code: ","link":"https://violeteternal.github.io/post/ti-jie-p1462-tong-wang-ao-ge-rui-ma-de-dao-lu/"},{"title":"【学习笔记】矩阵","content":"矩阵： 矩阵(Matrix)是指一个按照长方阵列排列的集合。一个由 nnn 行 mmm 列个数字排列的列表称为“ mmm 行 nnn 列”的矩阵，简称 n∗mn*mn∗m 矩阵，记作： {a1a2a3...amam+1.........a2m...............am(n−1)+1.........anm}\\begin{Bmatrix} a_1&amp;a_2&amp;a_3&amp;...&amp;a_m\\\\ a_{m+1}&amp;...&amp;...&amp;...&amp;a_{2m}\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ a_{m(n-1)+1}&amp;...&amp;...&amp;...&amp;a_{nm} \\end{Bmatrix}⎩⎪⎪⎨⎪⎪⎧​a1​am+1​...am(n−1)+1​​a2​.........​a3​.........​............​am​a2m​...anm​​⎭⎪⎪⎬⎪⎪⎫​ 矩阵加法/减法： 令 A,BA,BA,B 都是 n∗mn*mn∗m 矩阵，则 A+B=CA+B=CA+B=C ，满足： C={a1+b1a2+b2a3+b3...am+bmam+1+bm+1.........a2m+b2m...............am(n−1)+1+bm(n−1)+1.........anm+bnm}C=\\begin{Bmatrix} a_1+b_1&amp;a_2+b_2&amp;a_3+b_3&amp;...&amp;a_m+b_m\\\\ a_{m+1}+b_{m+1}&amp;...&amp;...&amp;...&amp;a_{2m}+b_{2m}\\\\ ...&amp;...&amp;...&amp;...&amp;...\\\\ a_{m(n-1)+1}+b_{m(n-1)+1}&amp;...&amp;...&amp;...&amp;a_{nm}+b_{nm} \\end{Bmatrix}C=⎩⎪⎪⎨⎪⎪⎧​a1​+b1​am+1​+bm+1​...am(n−1)+1​+bm(n−1)+1​​a2​+b2​.........​a3​+b3​.........​............​am​+bm​a2m​+b2m​...anm​+bnm​​⎭⎪⎪⎬⎪⎪⎫​ 简单来说，即 Ci,j=Ai,j+Bi,jC_{i,j}=A_{i,j}+B_{i,j}Ci,j​=Ai,j​+Bi,j​ ，减法同理。 矩阵乘法： A∗B=CA*B=CA∗B=C 满足 Ci,j=∑k=1nAi,k∗Bk,jC_{i,j}=\\sum_{k=1}^{n}{A_{i,k}*B_{k,j}}Ci,j​=∑k=1n​Ai,k​∗Bk,j​ 矩阵乘法能够实现，仅当 AAA 的行数与 BBB 的列数相等时。 举个栗子： A={123123}A=\\begin{Bmatrix}1&amp;2&amp;3\\\\1&amp;2&amp;3\\\\\\end{Bmatrix}A={11​22​33​} ， B={321321}B=\\begin{Bmatrix}3&amp;2\\\\1&amp;3\\\\2&amp;1\\\\\\end{Bmatrix}B=⎩⎨⎧​312​231​⎭⎬⎫​ 那么对于 C=A∗BC=A*BC=A∗B ，则 C1,1=A1,1∗B1,1+A1,2∗B2,1+A1,3∗B3,1C_{1,1}=A_{1,1}*B_{1,1}+A_{1,2}*B_{2,1}+A_{1,3}*B_{3,1}C1,1​=A1,1​∗B1,1​+A1,2​∗B2,1​+A1,3​∗B3,1​ 简单来讲就是 C1,1=∑k=1n=3A1,k∗∑k=1m=3Bk,1C_{1,1}=\\sum_{k=1}^{n=3}{A_{1,k}}*\\sum_{k=1}^{m=3}{B_{k,1}}C1,1​=∑k=1n=3​A1,k​∗∑k=1m=3​Bk,1​ 那么矩阵乘法的代码实现即是： 矩阵快速幂： 对于一个矩阵 GGG 来说， GkG^kGk 中 Gi,jG_{i,j}Gi,j​ 的含义为从 iii 走到 jjj 步数为 kkk 的方案数。 不用理解太多，就是用矩阵实现快速幂即可，将数乘换成矩阵乘法（蒟蒻改了一下午，才发现把 iii 打成了 jjj） LuoguP3390 AC Code： ","link":"https://violeteternal.github.io/post/xue-xi-bi-ji-ju-zhen/"},{"title":"【学习笔记】同余","content":"同余： 定义： aaa 与 bbb 同余，当且仅当 aaa 与 bbb 除以 ppp 的余数相同，记作 aaa 与 bbb 模 ppp 同余，写作 a≡b(modp)a \\equiv b \\pmod pa≡b(modp)。 同余的性质： 若 a≡b(modp)a \\equiv b \\pmod pa≡b(modp) ，则有 a+c≡b+c(modp)a+c \\equiv b+c \\pmod pa+c≡b+c(modp) 若 a≡b(modp)a \\equiv b \\pmod pa≡b(modp) ，则有 ac≡bc(modp)ac \\equiv bc \\pmod pac≡bc(modp) 若 a≡b(modp)a \\equiv b \\pmod pa≡b(modp) ，且 c≡d(modp)c \\equiv d \\pmod pc≡d(modp) ，则有 a±c≡b±d(modp)a \\pm c \\equiv b \\pm d \\pmod pa±c≡b±d(modp) 若 ac≡bc(modp)ac \\equiv bc \\pmod pac≡bc(modp) ，且 (c,m)=1(c,m)=1(c,m)=1 ，那么 a≡b(modp)a \\equiv b \\pmod pa≡b(modp) 若 a≡b(modp)a \\equiv b \\pmod pa≡b(modp) ，且 c≡d(modp)c \\equiv d \\pmod pc≡d(modp) ，则有 ac≡bd(modp)ac \\equiv bd \\pmod pac≡bd(modp) 若 a≡b(modp)a \\equiv b \\pmod pa≡b(modp) ，则有 ac≡bc(modpc)ac \\equiv bc \\pmod {pc}ac≡bc(modpc) 若 aaa 和 bbb 都是整数，且 ddd 和 mmm 都是正整数， ddd 是 a,b,ma,b,ma,b,m 中任一公因数，则如果 a≡b(modm)a \\equiv b \\pmod ma≡b(modm) 成立时，则有 ad≡bd(modpd)\\frac{a}{d} \\equiv \\frac{b}{d} \\pmod {\\frac{p}{d}}da​≡db​(moddp​) 若 aaa 和 bbb 都是整数，且 ddd 和 mmm 都是正整数，且 d∣md|md∣m，则如果 a≡b(modm)a \\equiv b \\pmod ma≡b(modm) 成立时，则有 a≡b(modd)a \\equiv b \\pmod da≡b(modd) 。 若 aaa 和 bbb 都是整数，且 ddd 和 mmm 都是正整数，如果 a≡b(modm)a \\equiv b \\pmod ma≡b(modm) 成立时，则有 (a,m)=(b,m)(a,m)=(b,m)(a,m)=(b,m) ，且若如果 ddd 能够整除 a,b,ma,b,ma,b,m 中的任意一个， ddd 也就能整除 a,ba,ba,b 中的另一个。 扩展欧几里得算法： 若 (a,b)=d(a,b)=d(a,b)=d ，那么对于方程 ax+by=dax+by=dax+by=d 的解有一组特殊解为 x=x0,y=y0x=x_0,y=y_0x=x0​,y=y0​ ，那么该方程的通解为 x=x0+bd∗t,y=y0−ad∗tx=x_0+\\frac{b}{d}*t,y=y_0-\\frac{a}{d}*tx=x0​+db​∗t,y=y0​−da​∗t ，而我们用这个通解来逆向推出 gcdgcdgcd ，因为我们有欧几里得定理： (a,b)=d(a,b)=d(a,b)=d ，则有 (b,a mod b)=d(b,a \\bmod b)=d(b,amodb)=d 那么就会推出： d=a∗y1+b∗(x1−y1∗ab)d=a*y_1+b*(x_1-y_1*\\frac{a}{b})d=a∗y1​+b∗(x1​−y1​∗ba​) 在这个算式中满足： x=y1,y=x1−ab∗y1x=y_1,y=x_1-\\frac{a}{b}*y_1x=y1​,y=x1​−ba​∗y1​ 扩欧解同余方程： 对于方程 ax≡1(modb)ax \\equiv 1 \\pmod bax≡1(modb) ，已知 aaa 与 bbb ，求出最小的 xxx 。 LuoguP1082 妥妥的扩欧模板题： 中国剩余定理： LuoguP1495曹冲养猪 有一个同余方程组满足 {x≡a1(modm1)x≡a2(modm2)x≡a3(modm3)x≡a4(modm4)x≡a5(modm5)......x≡ak(modmk)\\left\\{\\begin{matrix}x \\equiv a_1 \\pmod {m_1} \\\\x \\equiv a_2 \\pmod {m_2} \\\\x \\equiv a_3 \\pmod {m_3} \\\\x \\equiv a_4 \\pmod {m_4} \\\\x \\equiv a_5 \\pmod {m_5} \\\\...... \\\\x \\equiv a_k \\pmod {m_k} \\end{matrix}\\right.⎩⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎧​x≡a1​(modm1​)x≡a2​(modm2​)x≡a3​(modm3​)x≡a4​(modm4​)x≡a5​(modm5​)......x≡ak​(modmk​)​ ，求出最小的 xxx 。 思路： 设 M=m1m2m3...mkM=m_1m_2m_3...m_kM=m1​m2​m3​...mk​ ，令 Mi=MmiM_i=\\frac{M}{m_i}Mi​=mi​M​ ，tit_iti​ 是 MiM_iMi​ 的逆元，有 Miti≡1(modm)iM_it_i \\equiv 1 \\pmod m_iMi​ti​≡1(modm)i​ 则 x=∑i=1kaiMitix=\\sum_{i=1}^{k}{a_iM_it_i}x=∑i=1k​ai​Mi​ti​ 则可构造特殊解 x0=x+k∗Mx_0=x+k*Mx0​=x+k∗M 最小正整数解即为 xmin=x0 mod Mx_{min}=x_0 \\bmod Mxmin​=x0​modM P3868 AC Code: 头图来源： Bilibili Undertale同人AU DigitFault ","link":"https://violeteternal.github.io/post/xue-xi-bi-ji-tong-yu-andju-zhen/"},{"title":"【题解】NOIP2022.01.26模拟赛","content":"题目I——集合均值(mos) MOS=Mean Of Set 一道完美的数学题，指不推公式你完全不知道它居然求的是**（暂且保密）。 因为每一次都需要从B中随机一个数，那么第一次取到了 aia_iai​ 的话，求到的 ansansans 应该加上 ai2\\frac{a_i}{2}2ai​​ ，以此类推，当第二次取到了 aja_jaj​ 的时候，求到了 ansansans 就取到 ai+aj3\\frac{a_i+a_j}{3}3ai​+aj​​ ，然后继续计算，我们会发现 BBB 中的所有数对最终答案的贡献系数都是一样的，并且其贡献系数与其在 BBB 中的位置没有关系，只会和 BBB 的大小有关系，然后继续推算，答案就显而易见了： ans=f(∣B∣)∑x∈Baxans=f(|B|)\\sum_{x\\in B}{a_x}ans=f(∣B∣)∑x∈B​ax​ 那么现在的问题就在于求出 f(i)f(i)f(i) 了，我们可以模拟从 BBB 移动到 AAA 的过程，花费 OmO{m}Om 的时间，这也是 40pt40pt40pt 的做法。然而这道题的关键在于：我们最后求出的期望值是一个有理数 fracabfrac{a}{b}fracab ，所以我们需要进行有理数取余，而进行逆元操作。（逆元便是这道题的正解） 怎么想到使用逆元的： 首先，我们已经推出了 ans=f(∣B∣)∑x∈Baans=f(|B|)\\sum_{x\\in B}{a}ans=f(∣B∣)∑x∈B​a ，设 iii 为当前 AAA ，即已经已过去了的数的个数，那么 ∣B∣=i−1i|B|=\\frac{i-1}{i}∣B∣=ii−1​ 了。我们需要在计算的过程中取模，也就自然想到使用逆元了。（虽然考的时候完全没有想到） 具体来说： 暴力模拟求逆元可得 70pt70pt70pt 线性求逆元可得 100pt100pt100pt 事实上，我们需要的也是这些逆元的和即可，根据原作者的话来说，会有一种强力的的多项式高科技能使求逆元的复杂度达到 O(nmlog⁡nm)O(\\sqrt{nm}\\log{nm})O(nm​lognm) 。但在这道题来说(n∗m≦2∗107n*m ≦ 2*10^7n∗m≦2∗107)，线性求逆元已经完全足够了。 Task One Ac Code: 题目II——聚烷撑乙二醇(pag) PAG=Play A Game 做题最大的收获是知道了 PAGPAGPAG 是聚烷撑乙二醇的意思 题目含义： 鲁迅曾经说过，要多去尝试，才能最终发现最优的答案。 鲁迅也还说过，要珍惜当下，把握住眼前的机会。 有 nnn 个随机数生成器，第 iii 个生成器可以均匀随机地生成 [Li,Ri][L_i,R_i][Li​,Ri​] 内的一个实数。 现在你要玩个游戏，从第 111 个生成器到第 nnn 个生成器，每次当前生成器会生成一个数，你需要选择： 相信鲁迅，拿走这个数，游戏结束。 相信鲁迅，放弃这个数和这个生成器，使用下一个生成器（前提是下一个生成器必须存在）。 求使用使得期望答案最大的策略时，期望答案是多少。 很玄学的题意和标题 思路详解： 其实想明白后十分简单，主要是想到这道题到底是怎样操作的。假设现在我们到了第 iii 的随机数生成器，第二个生成器产生的数的期望是 Y=Li+1+Ri+12Y=\\frac{L_{i+1}+R_{i+1}}{2}Y=2Li+1​+Ri+1​​ 。如果第 iii 个生成器产生了 XXX ，当 X&lt;YX&lt;YX&lt;Y 时，我们当然放弃 XXX 更优，反之则取出 XXX 。 那我们将 iii 与 i+1i+1i+1 扩展到 111 到 nnn 的思路。对于每一组来说，我们都这样来扩展答案，就可以得到下面的算式： 当 ans&lt;Lians&lt;L_ians&lt;Li​ 时 ans=Li+Ri2ans=\\frac{L_i+R_i}{2}ans=2Li​+Ri​​ 当 Li&lt;ans&lt;RiL_i&lt;ans&lt;R_iLi​&lt;ans&lt;Ri​ 时 ans=ans∗(ans−Li)+ans+Ri2∗(Ri−ans)Ri−Lians=\\frac{ans*(ans-L_i)+\\frac{ans+R_i}{2}*(R_i-ans)}{R_i-L_i}ans=Ri​−Li​ans∗(ans−Li​)+2ans+Ri​​∗(Ri​−ans)​ 否则， ans=ansans=ansans=ans ，当然，这步不用在代码里体现。 明白这件事之后，还有一个需要注意的，那就是： 我们在扩展答案是应该从 NNN 到 111 扩展： 因为我们只有在知道了 i+1i+1i+1 的区间之后才能知道第 iii 个到底取不取。 Task Two Ac Code： 头图来源： Warma ","link":"https://violeteternal.github.io/post/ti-jie-noip20220126-mo-ni-sai/"},{"title":"【题解】P1144 最短路计数","content":"题目链接： 最短路计数 题目概述&amp;解题思路： 字面意思，不多做解释。求出所有的最短路个数，对 106+310^6+3106+3 取模。当然，如果起点到编号为 iii 的点不连通当然数目就为0啦。 对于简单的思路，那就是跑出最短路，再跑一遍遍历，看有多少种情况能够走到 iii 点，然后统计。但是这样是绝对会超时的 对于 100100%100 的数据, N≦1000000,M≦2000000N ≦ 1000000,M ≦ 2000000N≦1000000,M≦2000000 .所以我们应该选择 SPFA ，啊对，就是选择SPFA，有些算法死了，它还活着。 我们可以用一个数组 AnsLAnsLAnsL 来存储从 111 号点到第 iii 号点的最短路个数，然后一边跑 SPFASPFASPFA 一边修改 AnsLAnsLAnsL 的值，即当我们当前从 uuu 点跑到了 vvv 点的话费与 DistvDist_vDistv​ 的值相同时，那么现在是一条目前找到的最短路（之后可能会存在更短路），那么就有： Ansv=Ansu+1Ans_v=Ans_u+1Ansv​=Ansu​+1 的推导公式。 而如果我们找到了更短路，那就把当前点的计数清零。从 uuu 点出发到的 vvv 点的路即是最短路（目前），则传递答案为： 这就是两种传递的方式，也就是本题最关键的代码核心。 其他的注意事项则在代码里体现： ","link":"https://violeteternal.github.io/post/ti-jie-p1144-zui-duan-lu-ji-shu/"},{"title":"【题解】UVA318 Domino Effect","content":"题解： 题目链接 这道题明明很简单我却被卡了很多次 说说这道题的思路： 题目很冗长，但其实理解下来很简单，不然为什么是黄题呢。 题意解释： 输入一个 NNN 个点， MMM 条边的无向图，每条边的起点，终点和权值。找出从编号为 111 的点能够到达的最远地点，这个地点可以在点上，也可以在边上。 对于这道题来说，最远的地方，只会有两种情况： *在某一个点上； *在某两点之间。 从起点 111 开始，对图上所有点走一遍最短路，找出到达最远的点，这就是第一种情况的答案，我们可以记录一次。然后将编号 222 至编号 NNN 的之间的全部点都跑一次，求出最远的边。 在这里，最朴素我刚开始想到的的方法就是求出到达两点的时间，然后根据时间差按比例分配这条边的权值，就是两边相遇的地点即时间。 但是， 实际上，换个角度思考，两组多米诺相遇的时间是一致的，所以从其中一点出发到另一点出发到的那个最远点时间一样，即是从起点到 iii 点加上起点到 jjj 点的距离再加上这条边的权值。这条边的最远时间就是： Valuei,j=(Disi+Disj+Pathi.j)/2Value_{i,j}=(Dis_i+Dis_j+Path_{i.j})/2Valuei,j​=(Disi​+Disj​+Pathi.j​)/2 上述即是对于答案的枚举，最坏情况为 O(N2)O(N^2)O(N2) ，这道题的 N≤500N≤500N≤500 完全足够。 最短路板块： 对于像我这种蒟蒻来说，有 333 种方法： Floyd： 通过考虑最佳子路径来得到最佳路径。单独一条边的路径也不一定是最佳路径。从任意一条单边路径开始。所有两点之间的距离是边的权的和，(如果两点之间没有边相连,则为 INFINFINF ）。从第一个顶点开始，依次将每个顶点作为媒介 kkk ，然后对于每一对顶点 uuu 和 vvv ，查看其是否存在一条经过 kkk 的，距离比已知路径更短的路径，如果存在则更新它。 Floyd的时间复杂度为 O(N3)O(N^3)O(N3) ，这种算法其实是拿来求全源最短路的，但放在单源最短路的题里依然使用，还是因为数据太小，所以可以选择。 SPFA已经死了： SPFA其实是另一种最短路算法Bellman-Ford的队列优化，但我们一般不使用。（因为太蒻了） 实际上，SPFA的实现与BFS相差无异。不同的是BFS中一个点如果出了队列就不再会进入队列，而在SPFA中如果一个点出了队列，它还有机会能够进入队列。因为一个点在对别的点进行松弛操作时，自己的最小值也同样会被自己修改过的点再次修改。 SPFA的复杂度并不是很稳定，最坏情况为 O(NM)O(NM)O(NM) 。 一般来说，随机数据的题SPFA和Dijkstra无异，但一般来说，有负权的图使用SPFA，因为Dijkstra不能处理负边权；而在一些毒瘤题里，就会出现关于SPFA…… 代码如下： 这道题过了最多的正解——Dijkstra： Dijkstra算法采用的是一种贪心的策略，建立一个数组 disdisdis 来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合： TTT ，初始时，原点s的路径权重被赋为 000 （即 diss=0dis_s=0diss​=0 ）。 若对于顶点 sss存在能直接到达的边 (s,m)(s,m)(s,m) ，则把 dismdis_mdism​设为 w(s,m)w(s,m)w(s,m) ,同时把所有其他（ sss 不能直接到达的）顶点的路径长度设为无穷大。 初始时，集合顶点 sss 。 然后，从 disdisdis 数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到 TTT 中，此时完成一个顶点。 然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短——如果是，那么就替换这些顶点在dis中的值；然后，又从 disdisdis 中找出最小值，重复上述动作，直到 TTT 中包含了图的所有顶点。 这就是Dijkstra的基本思路，但是在深度学习之后，我们一般使用的是Dijkstra的二叉堆（优先队列）优化： 而对于最短路来说，我们需要的是小根堆，优先队列初始大根堆。所以我们要重载一次。 结构体定义如下： 这道题的其他注意事项： *因为有多组数据，所以记得初始化所有相关变量 *多米诺的英文复数加的是 eseses！！！ *输出格式严格按照题目要求，句子后有两个 \\n\\n 补充一点我的代码风格： *我喜欢自己重写一些简单的函数代替STL库：maxmaxmax，minminmin，sortsortsort *每一个函数名之前都会加入一个类似于水印作用的标识符under，所以copy的同学记得删掉，而对于under的含义，请移步Undertale 蒟蒻第一篇题解，求过QWQ，并厚颜无耻的要波赞。 给上Dijkstra的AC代码： ","link":"https://violeteternal.github.io/post/ti-jie-uva318-domino-effect/"},{"title":"【学习笔记】欧拉函数","content":"定义： 指的是满足小于等于NNN且与NNN互质的数目和。 欧拉公式求解公式： 对于一个正整数NNN满足： φ(x)=∑k[(k,n)=1][k∈N][k&lt;n]\\varphi(x)=\\sum_{k}[(k, n)=1][k \\in N][k&lt;n]φ(x)=∑k​[(k,n)=1][k∈N][k&lt;n] 则有 φ(n)=n(1−1p1)(1−1p2)(1−1p3)⋯(1−1pk)\\varphi(n)=n\\left(1-\\frac{1}{p_{1}}\\right)\\left(1-\\frac{1}{p_{2}}\\right)\\left(1-\\frac{1}{p_{3}}\\right) \\cdots\\left(1-\\frac{1}{p_{k}}\\right)φ(n)=n(1−p1​1​)(1−p2​1​)(1−p3​1​)⋯(1−pk​1​) 欧拉函数的性质： 当N=0N=0N=0时： φ(0)=0\\varphi(0)=0φ(0)=0. 当N=1N=1N=1时： φ(1)=1\\varphi(1)=1φ(1)=1.因为1与自身互质。 当NNN为质数时： φ(N)=N−1\\varphi(N)=N-1φ(N)=N−1. 如果PPP是质数，而NNN是PPP的正整数次方： φ(PN)=PN(1−1p)\\varphi(P^N)=P^N(1-\\frac{1}{p})φ(PN)=PN(1−p1​) 欧拉定理： 设a,m∈N+a,m \\in N^+a,m∈N+，且(a,m)=1(a,m)=1(a,m)=1，那么则有 aφ(m)≡1(modm)a^{\\varphi(m)} \\equiv 1 \\pmod maφ(m)≡1(modm) 且aaa对模mmm的阶δm(a)\\delta_m(a)δm​(a)必须整除φ(a)\\varphi(a)φ(a). 证明： 取模mmm的缩系，a1,a2,a3......aφ(m)a_1,a_2,a_3......a_{\\varphi(m)}a1​,a2​,a3​......aφ(m)​， 则aa1,aa2,aa3......aaφ(m)aa_1,aa_2,aa_3......aa_{\\varphi(m)}aa1​,aa2​,aa3​......aaφ(m)​也是mmm的缩系. 故有∏i=1φ(m)ai≡∏i=1φ(m)aai≡aφ(m)∏i=1φ(m)ai(modm)\\prod_{i=1}^{\\varphi(m)}a_i \\equiv \\prod_{i=1}^{\\varphi(m)}aa_i \\equiv a^{\\varphi(m)}\\prod_{i=1}^{\\varphi(m)}a_i \\pmod m∏i=1φ(m)​ai​≡∏i=1φ(m)​aai​≡aφ(m)∏i=1φ(m)​ai​(modm) 则可以推出aφ(m)≡1(modm)a^{\\varphi(m)} \\equiv 1 \\pmod maφ(m)≡1(modm). 证毕 欧拉定理可以推出费马小定理： 如果p是一个质数，而整数aaa不是ppp的倍数， 则有a(p−1)≡1(modp)a^{(p-1)} \\equiv 1 \\pmod pa(p−1)≡1(modp)。 ","link":"https://violeteternal.github.io/post/xue-xi-bi-ji-ou-la-han-shu/"},{"title":"【学习笔记】线段树","content":"线段树是用来维护区间权值的一种数据结构，根据同机房巨佬而言，一般需要使用线段树的题考点都不在线段树上，不过线段树真滴好用 线段树的操作： Ⅰ.建树 我的习惯为使用结构体存储（就和链式前向星一样），也可以分开打： 一般来说，线段树的数组需要开四倍 NNN 空间，因为他比线性结构要多一层，而开四倍一般不会爆。 代码讲解： 对于其中之一 Tree[p]Tree[p]Tree[p] 中： lll 表示第p个编号所表示的区域起点为原线性结构的 AlA_lAl​ ； rrr 表示第p个编号所表示的区域终点为原线性结构的 ArA_rAr​ ； 子节点保证： l=rl=rl=r ； datdatdat 表示该区域的一个数据，一般视题目而定，且 datdatdat 的个数也不定。 tagtagtag 可有也可不有（如果是区间修改的题一般都有），表示“懒惰标记”，之后详解。 ppp 结点的子结点为 p∗2p*2p∗2 和 p∗2+1p*2+1p∗2+1 ，一般在代码中写为 p&lt;&lt;1p&lt;&lt;1p&lt;&lt;1 和 p&lt;&lt;1∣1p&lt;&lt;1|1p&lt;&lt;1∣1 来节约时间（因为位运算时间复杂度＜乘法复杂度） 建树一般使用递归建树： Ⅱ.查询 以查询该区间权值和为例： 如果该结点在需要查询的区间内，返回该点权值； 如果不在搜索子结点，如果需要的 lll 比该结点的 midmidmid 小，则搜索 (l,mid)(l,mid)(l,mid)；如果需要的 rrr 比该结点的 midmidmid 大，则搜索(mid+1,r)(mid+1,r)(mid+1,r)。 具体操作看函数： Ⅲ.单点修改 找到该点的编号，从下至上修改它的所有父结点直到，依然使用递归操作。 datdatdat 存储该区间的区间和： Ⅳ.向上传递（pushup） 即函数underPushUp，一般都是视题目而定。 以区间和为例： 似乎这个例子没什么说服力，不过的确是这样的。 Ⅴ.向下传递（pushdown/spread） 只限于懒惰标记。当我们需要改变该区间中的子区间才会向下传递，这样可以优化时间，否则每一次区间修改都会花费 O(N)O(N)O(N) 的时间复杂度。 依然以区间和为例： Ⅵ.区间修改 使用懒惰标记，可以让时间复杂度降到 O(logN)O(logN)O(logN) 。 依然以区间和为例： 一些练习 区间修改区间查找模板题 区间最大子段和模板题 P2574 XOR的艺术 区间求sin和，需要使用数学知识 卡常卡码风的毒瘤题 头图来源： Warma ","link":"https://violeteternal.github.io/post/xue-xi-bi-ji-xian-duan-shu/"}]}